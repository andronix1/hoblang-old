import "tcp/lib.hob" as tcp;
import "libc/lib.hob" as c;
# import "pthread/lib.hob" as pthread;

use c::mem;
use c::io;
use c::process;
# use pthread::thread;

# global / export

fun handle_conn(handle: *tcp::handle::TcpClientHandle): void {
	io::puts("new connection!\0");
	var buf = [0 as u8, 0, 0, 0, 0];
	while tcp::handle::read(handle, buf, 5) == 5 { }
	tcp::handle::send(handle, "HTTP/1.1 200 OK\n\r", 17);
	tcp::handle::send(handle, "Content-Length: 14\n\r", 9);
	tcp::handle::send(handle, "\n\r\n\r", 4);
	tcp::handle::send(handle, "hello, world!\n", 14);
	tcp::handle::close(handle);
	io::puts("connection closed!\0");
	# thread::exit(0 as *void);
}

fun main(): i32 {
    var server: tcp::server::TcpServer;
    if !tcp::server::init(&server, 9000) {
        return 1;
    }
    defer tcp::server::stop(&server);

	# var func = handle_conn;

	while true {
		# TODO: sizeof
		var client = mem::malloc(20) as *tcp::handle::TcpClientHandle;
		if !tcp::server::accept(&server, client) {
			return 1;
		}
		# var t: thread::Thread;
		# var attr: pthread::attr::Attr;
		# if thread::create(&t, 0 as *pthread::attr::Attr, func as fun (*void) -> *void, client as *void) != 0 {
		# 	io::puts("failed to create the thread!\0");
		# }
		handle_conn(client);
		mem::free(client as *void);
	}
    return 0;
}
