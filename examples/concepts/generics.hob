behaviour VectorAddMath {
    fun (Self) add(other: Self) -> Self
}

behaviour VectorLengthMath: VectorAddMath {
    fun (Self) sqrt() -> Self
    fun (Self) pow2() -> Self
    #`
        if i will add inlines or/and macros
        they also can be used here
    `#
}

behaviour VectorDotMath: VectorDotMath {
    fun (Self) mul(other: Self) -> Self
}

behaviour VectorMath = VectorLengthMath + VecDotMath;

struct Vec2[T: VectorMath] { x: T, y: T }

fun new[T: VectorMath](x: T, y: T) -> Vec2[T] {
    return struct Vec2[T] {
        x: x,
        y: y
    }
}

fun (Vec2[T]) dot[T: VectorMath](other: Vec2[T]) -> T {
    return self.x.mul(other.x)
        .add(self.y.mul(other.y));
}

fun (Vec2[T]) length[T: VectorMath](a: T, b: T) -> T {
    return a.pow2()
        .add(b.pow2())
        .sqrt();
}

#`
[] uses in indexes only, so there is no collisions like there:
    1 as u8 < 10
    ------------ <= expression
         ----    <= type?
            -    <= binop?            

It will be like:
    { 1, 2, 3 }[0]
    --------------  <= expression
               ---  <= idx expression
or
    super as []Duper[T, Y]
    ---------------------- <= expression
             ------------- <= type
               ----------- <= slice of
               -----       <= path
                    ------ <= generics (after paths only)
`#
